---
// import "deepmerge";
import preferences from "data/preferences.json";
import { getCollection, getEntry } from "astro:content";
import { Debug } from "astro/components";

export interface Props {
  pages?: any;
  id?: string;
  depth?: number;
  currentPath?: string;
}

interface PageTree {
  children?: any;
  parent: PageTree | undefined;
  title?: string;
  slug?: string;
  id?: string;
}

// https://stackoverflow.com/a/11433067
// Function: createNestedObject( base, names[, value] )
//   base: the object on which to create the hierarchy
//   names: an array of strings contaning the names of the objects
//   value (optional): if given, will be the last object in the hierarchy
// Returns: the last object in the hierarchy
// var createNestedObject = function (
//   base: Record<string, any>,
//   names: string[],
//   value: any
// ) {
//   // If a value is given, remove the last name and keep it for later:
//   var lastName = arguments.length === 3 ? names.pop() : false;

//   // Walk the hierarchy, creating new objects where needed.
//   // If the lastName was removed, then the last object is not set yet:
//   for (var i = 0; i < names.length; i++) {
//     base = base[names[i]] = base[names[i]] || {};
//   }

//   // If a value was given, set it to the last name:
//   if (lastName) base = base[lastName] = value;

//   // Return the last object in the hierarchy:
//   return base;
// };

function makeTree(pages: any) {
  const pageTree: PageTree = { children: {}, parent: undefined };

  pages.forEach((page: any) => {
    let path = page.slug.replace(/\/?index$/, "").split("/");

    let cursor = pageTree;

    for (var i = 0; i < path.length; i++) {
      if (!("children" in cursor)) {
        cursor.children = {};
      }

      if (!(path[i] in cursor?.children)) {
        cursor.children[path[i]] = {
          parent: undefined,
          title: path[i]
            .replaceAll("-", "")
            .replace(
              /\w\S*/g,
              (t: string) =>
                t.charAt(0).toUpperCase() + t.substring(1).toLowerCase()
            ),
        };
      }
      cursor = cursor.children[path[i]];

      if (i + 1 == path.length) {
        Object.assign(cursor, page);
        // if (cursor?.slug === "index") {
        //   cursor.slug = "/";
        // }
      }
    }
  });

  return pageTree;
}

async function getPageTree(): Promise<any> {
  // Get all online pages
  const collection = await getCollection("pages", ({ data }) => {
    return data.status === "online";
  });

  const pages = collection.map((e, i) => {
    return {
      slug: e.slug,
      title: e.data.title,
      id: e.id,
      // path: e.id.replace(/\..*$/, ""),
    };
  });

  return makeTree(pages);
}

const { id } = Astro.props;
const depth = typeof Astro.props.depth === "number" ? ++Astro.props.depth : 0;
const pages =
  typeof Astro.props.pages === "undefined"
    ? await getPageTree()
    : Astro.props.pages;

const Wrapper = depth ? Fragment : "nav";
---

{!depth && <Debug {pages} />}

<Wrapper>
  <ul>
    {
      "children" in pages &&
        Object.values(pages.children).map((page: any, i) => (
          <li>
            <a href={page?.slug && `/${page?.slug.replace(/index$/, "")}`}>
              {page?.title}
            </a>
            {"children" in page && <Astro.self depth={depth} pages={page} />}
          </li>
        ))
    }
  </ul>
</Wrapper>

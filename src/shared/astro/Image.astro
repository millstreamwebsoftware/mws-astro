---
import { inferRemoteSize } from "@mws-astro/filesystem";
import { Image as AstroImage } from "astro:assets";
import _preferences from "@data/preferences.json";
import { getImage } from "astro:assets";
const preferences = _preferences as unknown as Preferences;

type CssAlignment = "top" | "bottom" | "center" | "left" | "right";
export type CssAlign = `${CssAlignment} ${CssAlignment}` | CssAlignment;

type ImageSource =
  | {
      imageSource: "public";
      image: string;
    }
  | {
      imageSource: "remote";
      image: string;
    }
  | {
      imageSource: "assets";
      image: ImageMetadata | Promise<{ default: ImageMetadata }>;
    };

const DESKTOP_WIDTH = 1920;
const MOBILE_WIDTH = 768;
const IMAGE_MIN_WIDTH = 256;
const DPR = 2;

export interface Props {
  image: Parameters<typeof AstroImage>[0]["src"];
  width?: number;
  height?: number;
  fit?: "cover" | "contain";
  align?: CssAlign;
  alt?: string;
  classes?: string;
  background?: boolean;
  opacity?: number;
  quality?: "low" | "mid" | "high" | "max" | number;
  loading?: Parameters<typeof AstroImage>[0]["loading"];
  fixed?: boolean;
  placeholder?: boolean;
  widths?: number[] | null;
  displayWidth?: number;
  displayWidthMobile?: number;
}

const {
  classes,
  background,
  fit = "cover",
  quality = "high",
  opacity,
  fixed = false,
  alt = "",
  displayWidth = 1,
  displayWidthMobile = 1,
  loading = "lazy",
} = Astro.props;

// Get an ImgixClient instance if @imgix/js-core is installed and imgix is configured in preferences
const ixDomain = preferences.API?.imgix?.domain;
const ix = ixDomain
  ? await import("@imgix/js-core").then(
      ({ default: ImgixClient }) =>
        new ImgixClient({
          domain: ixDomain,
          secureURLToken: preferences.API?.imgix?.token,
        }),
      () => undefined,
    )
  : undefined;

const imageAssets = import.meta.glob(
  [
    // Assets
    "/src/assets/**/*.svg",
    "/src/assets/**/*.png",
    "/src/assets/**/*.jpg",
    "/src/assets/**/*.jpeg",
    "/src/assets/**/*.webp",
    "/src/assets/**/*.gif",
    "/src/assets/**/*.tiff",
    "/src/assets/**/*.avif",
  ],
  { eager: true, import: "default" },
);

if (!(Astro.props.image ?? false)) {
  console.warn("[Image] Image src was undefined.", Astro.props);
  return;
}

// Set image with type assurances provided by imageSource
const { image, imageSource } = ((image): ImageSource => {
  if (typeof image === "object") return { image, imageSource: "assets" };

  if (/^https?:\/\/.*/.test(image)) return { image, imageSource: "remote" };

  // let imageKey = Object.keys(imageAssets).find((k) => k === `/src${image}`);
  let imageKey = Object.keys(imageAssets).find((k) => k.endsWith(image));
  if (imageKey)
    return {
      image: imageAssets[imageKey] as Promise<{ default: ImageMetadata }>,
      imageSource: "assets",
    };

  return { image, imageSource: "public" };
})(Astro.props.image);

var src: string | undefined;
var srcset: string | undefined;
var srcWidth: number | undefined;
var srcHeight: number | undefined;
var sizes: string | undefined;

switch (imageSource) {
  case "remote":
    // Skip processing of SVGs
    if (/\.svg(?:\?.*)?$/.test(image)) {
      src = image;
      break;
    }

    if (ix) {
      src = ix.buildURL(image, {}, {});
      srcset = ix.buildSrcSet(
        image,
        {
          auto: "format",
          fit: "max", // Contain output within width and height without scaling up
          q:
            typeof quality === "number"
              ? quality
              : { low: 50, mid: 60, high: 75, max: 100 }[quality],
        },
        {
          maxWidth: Math.floor(DESKTOP_WIDTH * displayWidth * DPR),
          minWidth: 128,
        },
      );

      let widths = srcset.split(",").map((src) => parseInt(src.split(" ")[1]));
      sizes = createImageSizes(widths);
      break;
    }

    // Don't optimise remote images in the editor
    if (ENV_BOOKSHOP_LIVE) {
      src = image;
      break;
    }

    // Get image width and allow fall-through to handle remote image via Astro's asset pipeline
    ({ width: srcWidth, height: srcHeight } = await inferRemoteSize(
      image,
    ).catch((e) => {
      console.warn(e);
      return { width: undefined, height: undefined };
    }));

    if (!(srcWidth && srcHeight)) {
      console.warn(`[Image] Failed to get remote size for image: ${image}`);
      src = image;
      break;
    }
  case "assets":
    let w = srcWidth ?? ((await image) as ImageMetadata)?.width;
    let h = srcHeight ?? ((await image) as ImageMetadata)?.height;

    let widths =
      Astro.props.widths === undefined
        ? createImageWidths(w, h)
        : (Astro.props.widths ?? undefined);
    sizes =
      (widths && widths.length > 1 && createImageSizes(widths)) || undefined;

    // Don't bother using widths/sizes for images with one width
    if (widths && widths.length < 2) {
      widths = undefined;
      sizes = undefined;
    }

    ({
      src,
      srcSet: { attribute: srcset },
    } = await getImage({
      src: image,
      width: srcWidth,
      height: srcHeight,
      widths,
      sizes,
      quality,
    }));
    break;
  case "public":
    src = image.replace(/^\/?public\/?/, "/");
    break;
}

const style = {
  "--align": Astro.props.align ?? "center",
  "--opacity": opacity,
};

function createImageWidths(width: number, _height: number) {
  let widths: number[] = [];

  const maxWidth = Math.min(
    Math.max(
      DESKTOP_WIDTH * displayWidth * DPR,
      MOBILE_WIDTH * displayWidthMobile * DPR,
    ),
    width,
  );

  for (let w = maxWidth; w > IMAGE_MIN_WIDTH; w /= 2) {
    widths.push(Math.ceil(w));
  }

  return widths;
}

// Generate sizes
// TODO: Better image sizes for mobile - should sometimes be larger than desktop
function createImageSizes(widths: number[]) {
  const _sizes = [...widths]
    .sort((a, b) => b - a)
    .reduce<string[]>((a, c, i, o) => {
      if (a.length) a.push(`(max-width: ${o[i - 1]}px) ${c}px`);
      else a.push(`${c}px`);

      return a;
    }, []);

  _sizes.push("auto"); // Currently only supported on chromium - Only when loading="lazy"
  _sizes.reverse();
  return _sizes.join(", ");
}
---

<img
  {src}
  {srcset}
  {sizes}
  {alt}
  class:list={[classes, { background, fixed }]}
  {style}
  data-fit={fit}
  {loading}
/>

<style>
  img {
    object-fit: cover;
    object-position: var(--align);
    background-size: cover;
    background-position: var(--align);
    width: 100%;
    height: 100%;
    opacity: var(--opacity, 1);
    /* width: auto;
        height: auto; */
  }

  img[data-fit="contain"] {
    object-fit: contain;
    background-size: contain;
  }

  img.background {
    position: absolute;
    height: 100%;
    inset: 0;
  }

  img.fixed {
    position: fixed;
    inset: 0;
  }
</style>

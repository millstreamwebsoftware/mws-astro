---
import { inferRemoteSize } from "@mws-astro/filesystem";
import { Image as AstroImage } from "astro:assets";
import _preferences from "@data/preferences.json";
import { getImage } from "astro:assets";
const preferences = _preferences as unknown as Preferences;

type CssAlignment = "top" | "bottom" | "center" | "left" | "right";
export type CssAlign = `${CssAlignment} ${CssAlignment}` | CssAlignment;

type ImageSource = {
  imageSource: "public"
  image: string,
} | {
  imageSource: "remote"
  image: string,
} | {
  imageSource: "assets"
  image: ImageMetadata | Promise<{default: ImageMetadata}>,
};

const DESKTOP_WIDTH = 1920;
const MOBILE_WIDTH = 768;
const IMAGE_MIN_WIDTH = 256;
const DPR = 2;

export interface Props {
  image: Parameters<typeof AstroImage>[0]["src"];
  width?: number;
  height?: number;
  fit?: "cover" | "contain";
  align?: CssAlign;
  alt?: string;
  classes?: string;
  background?: boolean;
  opacity?: number;
  quality?: "low" | "mid" | "high" | "max" | number;
  loading?: Parameters<typeof AstroImage>[0]["loading"];
  fixed?: boolean;
  placeholder?: boolean;
  widths?: number[] | null;
  displayWidth?: number;
  displayWidthMobile?: number;
}

const {
  classes,
  background,
  fit = "cover",
  quality = "high",
  opacity,
  fixed = false,
  alt = "",
  displayWidth = 1,
  displayWidthMobile = 1,
  loading = "lazy",
} = Astro.props;

// Get an ImgixClient instance if @imgix/js-core is installed and imgix is configured in preferences
const ixDomain = preferences.API?.imgix?.domain;
const ix = ixDomain ?
  await import("@imgix/js-core").then(
    ({default: ImgixClient}) => new ImgixClient({
      domain: ixDomain,
      secureURLToken: preferences.API?.imgix?.token
    }),
    () => undefined)
  : undefined;

const imageAssets = import.meta.glob([
  // Assets
  "/src/assets/**/*.svg",
  "/src/assets/**/*.png",
  "/src/assets/**/*.jpg",
  "/src/assets/**/*.jpeg",
  "/src/assets/**/*.webp",
  "/src/assets/**/*.gif",
  "/src/assets/**/*.tiff",
  "/src/assets/**/*.avif",
], {eager: true, import: "default"});

// Set image with type assurances provided by imageSource
const {image, imageSource} = ((image): ImageSource => {
  if (typeof image === "object")
    return {image, imageSource: "assets"};

  if (/^https?:\/\/.*/.test(image))
    return {image, imageSource: "remote"};

  let imageKey = Object.keys(imageAssets).find((k) => k === `/src${image}`);
  if (imageKey)
    return {
      image: imageAssets[`/src${image}`] as Promise<{default: ImageMetadata}>,
      imageSource: "assets",
    };

  return {image, imageSource: "public"};
})(Astro.props.image);

var src: string | undefined;
var srcset: string | undefined;
var srcWidth: number | undefined;
var srcHeight: number | undefined;
var sizes: string | undefined;

switch (imageSource) {
  case "remote":
    // Skip processing of SVGs
    if (/\.svg(?:\?.*)?$/.test(image)) {
      src = image;
      break;
    }

    if (ix) {
      src = ix.buildURL(image, {}, {});
      srcset = ix.buildSrcSet(image, {
        auto: "format",
        fit: "max", // Contain output within width and height without scaling up
        q: typeof quality === "number" ? quality : {"low": 50, "mid": 60, "high": 75, "max": 100}[quality]
      }, {
        maxWidth: Math.floor(DESKTOP_WIDTH * displayWidth * DPR),
        minWidth: 128,
      });

      let widths = srcset.split(",").map((src) => parseInt(src.split(" ")[1]));
      sizes = createImageSizes(widths);
      break;
    }

    // Don't optimise remote images in the editor
    if (ENV_BOOKSHOP_LIVE) {
      src = image;
      break;
    }

    // Get image width and allow fall-through to handle remote image via Astro's asset pipeline
    ({width: srcWidth, height: srcHeight} =
      await inferRemoteSize(image).catch((e) => {
          console.warn(e);
          return { width: undefined, height: undefined };
        }));
  case "assets":
    let w = srcWidth ?? (await image as ImageMetadata).width;
    let h = srcHeight ?? (await image as ImageMetadata).height;

    let widths = Astro.props.widths === undefined ? createImageWidths(w, h) : Astro.props.widths ?? undefined;
    sizes = widths && widths.length > 1 && createImageSizes(widths) || undefined;

    // Don't bother using widths/sizes for images with one width
    if (widths && widths.length < 2) {
      widths = undefined;
      sizes = undefined;
    }

    ({src, srcSet: {attribute: srcset}} = await getImage({src: image, width: srcWidth, height: srcHeight, widths, sizes, quality}));
    break;
  case "public":
    src = image.replace(/^\/?public\/?/, "/");
    break;
}

const style = {
  "--align": Astro.props.align ?? "center",
  "--opacity": opacity,
};

function createImageWidths(width: number, _height: number) {
  let widths: number[] = [];

  const maxWidth = Math.min(
    Math.max(
      DESKTOP_WIDTH * displayWidth * DPR,
      MOBILE_WIDTH * displayWidthMobile * DPR,
    ),
    width,
  );

  for (let w = maxWidth; w > IMAGE_MIN_WIDTH; w /= 2) {
    widths.push(Math.ceil(w));
  }

  return widths;
}

// Generate sizes
// TODO: Better image sizes for mobile - should sometimes be larger than desktop
function createImageSizes(widths: number[]) {
  const _sizes = [...widths]
    .sort((a, b) => b - a)
    .reduce<string[]>((a, c, i, o) => {
      if (a.length) a.push(`(max-width: ${o[i - 1]}px) ${c}px`);
      else a.push(`${c}px`);

      return a;
    }, []);

  _sizes.push("auto"); // Currently only supported on chromium - Only when loading="lazy"
  _sizes.reverse();
  return _sizes.join(", ");
}

---
<img
  {src}
  {srcset}
  {sizes}
  {alt}
  class:list={[classes, { background, fixed }]}
  {style}
  data-fit={fit}
  {loading}
  />

<style>
  img {
    object-fit: cover;
    object-position: var(--align);
    background-size: cover;
    background-position: var(--align);
    width: 100%;
    height: 100%;
    opacity: var(--opacity, 1);
    /* width: auto;
        height: auto; */
  }

  img[data-fit="contain"] {
    object-fit: contain;
    background-size: contain;
  }

  img.background {
    position: absolute;
    height: 100%;
    inset: 0;
  }

  img.fixed {
    position: fixed;
    inset: 0;
  }
</style>

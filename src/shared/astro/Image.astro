---
import { inferRemoteSize } from "@mws-astro/filesystem";
import { Image as AstroImage } from "astro:assets";

type CssAlignment = "top" | "bottom" | "center" | "left" | "right";
export type CssAlign = `${CssAlignment} ${CssAlignment}` | CssAlignment;

export interface Props {
  image: Parameters<typeof AstroImage>[0]["src"];
  width?: number;
  height?: number;
  fit?: "cover" | "contain";
  align?: CssAlign;
  alt?: string;
  // aspect?: number;
  classes?: string;
  background?: boolean;
  opacity?: number;
  quality?: "low" | "mid" | "high" | "max" | number;
  fixed?: boolean;
  placeholder?: boolean;
  // densities?: number[] | null;
  widths?: number[] | null;
}

const {
  classes,
  background,
  fit = "cover",
  quality = "high",
  opacity,
  fixed = false,
  alt = "",
} = Astro.props;


// await and unwrap image
let _image = ((i) => (typeof i === "object" && "default" in i ? i.default : i))(
  await Astro.props.image,
);
let image: typeof _image;
// let densities = Astro.props.densities;
let widths = Astro.props.widths;
let sizes: string;
let remote = false;
let width, height;

if (!_image) console.warn(`Image is undefined on page ${Astro.url.toString()}`);

// Image is remote
if (typeof _image == "string" && /^https?:\/\/.*/.test(_image)) {
  remote = true;

  const remoteSize = await inferRemoteSize(_image).catch((e) => {
    console.warn(e);
    return { width: undefined, height: undefined };
  });

  width ??= remoteSize.width;
  height ??= remoteSize.height;
  image = _image;
}

// Image is an SVG - Disable generating widths
if (/\.svg(?:\?.*)?$/.test(typeof _image === "string" ? _image : _image.src)) {
  widths = null;
}

// Image is local
if (typeof _image == "string" && !remote) {
  const images = import.meta.glob([
    // Assets
    "/src/assets/**/*.svg",
    "/src/assets/**/*.png",
    "/src/assets/**/*.jpg",
    "/src/assets/**/*.jpeg",
    "/src/assets/**/*.webp",
    "/src/assets/**/*.gif",
    "/src/assets/**/*.tiff",
    "/src/assets/**/*.avif",
    // Public
    "/public/**/*.svg",
    "/public/**/*.png",
    "/public/**/*.jpg",
    "/public/**/*.jpeg",
    "/public/**/*.webp",
    "/public/**/*.gif",
    "/public/**/*.tiff",
    "/public/**/*.avif",
  ]);

  let imagePaths: (keyof typeof images)[] = Object.keys(images).filter((i) =>
    i.endsWith(_image),
  );

  if (imagePaths.length > 1) {
    console.warn(`Ambiguous image import ${_image} -?-> ${imagePaths}!`);
  }

  let imagePath = imagePaths[0];

  if (imagePath in images) {
    image = ((await images[imagePath]()) as any)?.default;
  } else {
    console.warn(`[Missing Image] ${_image} was requested but is missing.`);
    // placeholder = false;
  }
}

image ??= _image;

if (typeof image !== "string" && image?.width && image?.height) {
  let aspect = image.width / image.height;

  if (Astro.props.width != undefined) {
    width = Astro.props.width;
    height = Math.floor(width / aspect);
  } else if (Astro.props.height != undefined) {
    height = Astro.props.height;
    width = Math.floor(height * aspect);
  } else {
    width = image.width;
    height = image.height;
  }
}
// else if (image?.width !== image?.height) {

// Automatically generate two image widths unless disabled (widths === null || widths)
if (widths === undefined && width && height) {
  let w = Math.min(1920, width)
  widths = [w, w / 2, w / 4];
}


// Generate sizes
if (widths) {
  // sizes = [];

  const _sizes = widths.toSorted((a,b) => b-a).reduce<string[]>((a, c, i, o) => {
    if (a.length)
    a.push(`(max-width: ${o[i-1]}px) ${c}px`);
    else
    a.push(`${c}px`);

    return a;
  },[]);

  _sizes.push("auto");
  _sizes.reverse();
  sizes = _sizes.join(",\n");
}

// (max-width: 360px) 240px,
// (max-width: 720px) 540px,
// (max-width: 1600px) 720px,
// 1600px


const style = {
  "--align": Astro.props.align ?? "center",
  "--opacity": opacity,
};

let fallbackImage: string | undefined;

if (typeof image === "string" && !remote) {
  fallbackImage = image.replace(/^\/?public\/?/, "/");
}
---

{
  fallbackImage ? (
    <img
      src={fallbackImage}
      class:list={[classes, { background, fixed }]}
      {style}
      data-fit={fit}
      {alt}
    />
  ) : (
    typeof image !== "undefined" && (
      // @ts-ignore
      <AstroImage
        src={image}
        {alt}
        {width}
        {height}
        class:list={[classes, { background, fixed }]}
        {style}
        widths={widths ?? undefined}
        sizes={sizes ?? undefined}
        data-fit={fit}
        {quality}
      />
    )
  )
}

<style>
  img {
    object-fit: cover;
    object-position: var(--align);
    background-size: cover;
    background-position: var(--align);
    width: 100%;
    height: 100%;
    opacity: var(--opacity, 1);
    /* width: auto;
        height: auto; */
  }

  img[data-fit="contain"] {
    object-fit: contain;
    background-size: contain;
  }

  img.background {
    position: absolute;
    height: 100%;
    inset: 0;
  }

  img.fixed {
    position: fixed;
    inset: 0;
  }
</style>

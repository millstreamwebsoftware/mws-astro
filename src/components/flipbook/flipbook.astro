---
import Section from "@layouts/Section.astro";
import Icon from "@shared/icon.astro";
import { getPDFThumbnail } from "@mws-astro/util";

export interface Props {
  url?: string;
}

const {url} = Astro.props;


// const filesize = Astro.pr


---
<Section component="flipbook" {...Astro.props}>
    <div class="flipbook" data-flipbook={url}>
        <div class="flipbook-viewport">
        </div>
        <div class="toolbar">
            <button data-action="<" title="Previous Page"><Icon name="carbon:chevron-left" height="1em"/></button>
            <button data-action="page-number" title="Page Number">1/1</button>
            <button data-action=">" title="Next Page"><Icon name="carbon:chevron-right" height="1em"/></button>
            <button data-action="download" title="Download PDF"><Icon name="carbon:download" height="1em"/></button>
        </div>
    </div>
</Section>

<script>
// import * as PDFJSLib from "pdfjs-dist";
import {getDocument, TextLayer, GlobalWorkerOptions} from "pdfjs-dist";
import PDFJSWorker from "pdfjs-dist/build/pdf.worker.min?worker&url";
GlobalWorkerOptions.workerSrc = PDFJSWorker;

type ResizeableCanvas = HTMLCanvasElement & {_resize?: Function};

document.addEventListener("DOMContentLoaded", setupFlipbook);
document.addEventListener("astro:after-swap", setupFlipbook);

function setupFlipbook() {
  const flipbooks = document.querySelectorAll<HTMLElement>("[data-flipbook]");
 
  flipbooks.forEach(async (flipbook) => {
    const flipbookViewport = flipbook.querySelector<HTMLDivElement>(".flipbook-viewport");
    const toolbar = flipbook.querySelector(".toolbar");
    const pageCounter = toolbar?.querySelector('[data-action="page-number"]');
    
    
    const evenSpreads = true;
    let page = 0;
    
    if (!flipbookViewport) return;
    const pdf = await getDocument(flipbook.dataset.flipbook).promise;
    
    updateCounter();
    
    // const observer = new MutationObserver((mut) => {});
    // observer.observe(flipbookViewport, {attributes: false, childList: true, subtree: true});
    
  
    
    function updateCounter() {
      if (!pageCounter) return;
      
      pageCounter.innerHTML = `${Math.max(Math.min(page + Number(!evenSpreads), pdf.numPages), 1)}/${pdf.numPages}`;
    }
    
    async function addSpread(prepend?: boolean) {
      const newSpread = document.createElement("div");
      newSpread.classList.add("flipbook-spread");
      (typeof prepend === "boolean") && newSpread.classList.add(prepend ? "previous" : "next");
      
      const newPage = document.createElement("div");
      const newCanvas = document.createElement("canvas");
      const newTextLayer = document.createElement("div");
      newPage.classList.add("flipbook-page")
      newTextLayer.classList.add("textLayer");
      newPage.appendChild(newCanvas);
      newPage.appendChild(newTextLayer);
      newSpread.appendChild(newPage.cloneNode(true));
      newSpread.appendChild(newPage);
      
      if (prepend) {
        flipbookViewport?.prepend(newSpread);
      } else {
        flipbookViewport?.append(newSpread);
      };
      
      return await renderSpread(newSpread);
    }
    
    async function turnPage(backward: boolean = false) {
      // const spreads = flipbookViewport.querySelectorAll<HTMLDivElement>(".flipbook-spread");
      if (!flipbookViewport) return;
      const spreads = Array.from(flipbookViewport.children);
      
      
      let oldPage = page;
      
      if (backward) {
        spreads.reverse()
        page -= 2;
      } else {
        page += 2;
      }
      
      if (page < 0 - Number(evenSpreads)) page = 0 - Number(evenSpreads);
      if (page > pdf.numPages) page = oldPage;
      
      if (page === oldPage) return;
      
      const [before, current, after] = spreads;
      
      before.parentNode?.removeChild(before);
      current.classList.add(backward ? "next" : "previous");
      after.classList.remove("next", "previous");
      
      updateCounter();
      await addSpread(backward);
    }
    
    toolbar?.addEventListener("click", async (e) => {
      if (!e.target) return;
      const target = e.target as HTMLElement;
      const button = target.closest<HTMLButtonElement>("button, .toolbar");
      if (!button || button.matches(".toolbar")) return;
      
      switch (button.dataset.action) {
        case "<":
          // page = page - 2;
          // if (page < 0) page = 0;
          // await renderPage(page);
          turnPage(true);
          break;
        case ">":
          // page = page + 2;
          // if (page >= pdf.numPages) page = 0;
          // await renderPage(page);
          turnPage();
          break;
        case "download":
          const a = document.createElement('a');
          const url = flipbook.dataset?.flipbook;
          if (!url) break;
          a.href = url;
          a.download = url.split('/').pop() || "";
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
        default:
          break;
      }
    })
    
    async function renderPage(canvas: ResizeableCanvas, num: number) {
      const context = canvas.getContext("2d");
      const text = canvas.parentElement?.querySelector<HTMLDivElement>(".textLayer");
      
      if (num < 0 || num >= pdf.numPages) {
        // canvas.width = canvas.width;
        // text && (text.innerHTML = "");
        canvas.parentElement?.classList.toggle("blank-page", true);
        
        return;
      }
      
      const page = await pdf.getPage(num+1);
      var viewport = page.getViewport({scale: 1.5});
      
      if (canvas.height != viewport.height)
      canvas.height = viewport.height;
      
      if (canvas.width != viewport.width)
      canvas.width = viewport.width;
      
      if (!context) throw Error("Canvas context missing");
      
      const renderTask = page.render({canvasContext: context, viewport}).promise;
      const textContent = page.getTextContent().then(async (textContent) => {
        if (!text) return;
        
        text.style.left = canvas.offsetLeft + 'px';
        text.style.top = canvas.offsetTop + 'px';
        text.style.height = canvas.offsetHeight + 'px';
        text.style.width = canvas.offsetWidth + 'px';
        
        const textLayer = new TextLayer({
          textContentSource: textContent,
          container: text,
          viewport: viewport,
        });
        
        canvas._resize = () => {
          const widthScaleFactor = canvas.clientWidth / (canvas.width / viewport.scale);
          const heightScaleFactor = canvas.clientHeight / (canvas.height / viewport.scale);
          const scaleFactor = Math.min(widthScaleFactor, heightScaleFactor); // account for object-fit contain
          
          text?.parentElement?.setAttribute("style", `--scale-factor: ${scaleFactor}`);
        }
        
        canvas._resize();
        
        const observer = new ResizeObserver((entries) => {
          entries.forEach((entry: any) => entry.target._resize && entry.target._resize());
        });
        
        observer.observe(canvas);
        
        text.innerHTML = "";
        await textLayer.render();
        
        text.style.left = "";
      });
      
      return await Promise.all([renderTask, textContent]);
    }
    
    async function renderSpread(spread: HTMLDivElement) {
      const canvases = Array.from(spread.querySelectorAll("canvas"));
      var spreadOffset = 0;
      
      if (spread.classList.contains("next")) {
        spreadOffset += 2;
      } else if (spread.classList.contains("previous")) {
        spreadOffset += -2;
      }
      
      return Promise.all(canvases.map(async (canvas, i) => {
        let p = page + i + spreadOffset - Number(evenSpreads);
        console.log(`Render page ${p} to`, canvas);
        return renderPage(canvas, p);
      }));
    }
    
    addSpread(true);
    addSpread();
    addSpread(false);
  });
}
</script>

<style lang="scss" is:global>
    div.flipbook {
        position: relative;
        
        .flipbook-viewport {
            display: grid;
            grid-template-areas: "flipbook";
            
            grid-template-rows: minmax(0, 1fr);
            perspective: 10000px;
        }
        
        .flipbook-spread {
            /* position: relative; */
            grid-area: flipbook;
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            grid-template-rows: 1fr;
            
            
            &.previous {
                .flipbook-page:nth-child(2) {
                    transform: rotateY(-180deg);
                }
            }
            & {
                z-index: auto;
                
                .flipbook-page {
                    z-index: 1;
                    transform: rotateY(0deg);
                }
            }
            &.next {
                .flipbook-page:nth-child(2) {
                    z-index: -1;
                }
                .flipbook-page:nth-child(1) {
                    transform: rotateY(180deg);
                }
            }
        }
        
        .flipbook-page {
            position: relative;
            transition: transform 0.2s ease-in-out, z-index 0.2s;
            backface-visibility: hidden;
            
            canvas {
                width: 100%;
                object-fit: contain;
                max-height: 90vh;
            }
            
            &:nth-child(1) {
                transform-origin: right;
                
                canvas {
                    object-position: right;
                }
                
                .textLayer {
                    right: 0;
                    left: unset;
                }
                
                &::after {
                    background: linear-gradient(to right, transparent 80%, 95%, rgb(0, 0, 0, 0.4));
                }
            }
            &:nth-child(2) {
                transform-origin: left;
                
                canvas {
                    object-position: left;
                }
                
                .textLayer {
                    left: 0;
                }
                
                &::after {
                    background: linear-gradient(to left, transparent 80%, 95%, rgb(0, 0, 0, 0.4));
                }
            }
            
            &::after {
                content: "";
                position: absolute;
                inset: 0;
                pointer-events: none;
            }
            
            &.blank-page::after {
                content: none;
            }
        }
    }
    
    .toolbar {
        position: absolute;
        bottom: 0;
        left: 50%;
        
        transform: translateX(-50%) translateY(110%);
        /* background-color: white; */
        
        z-index: 999;
        
        button {
            color: #333;
            border-color: #333;
            padding: .3em .8em;
            background-color: #fff;
            
            border-radius: var(--border-radius);
        }
    }

    .hiddenCanvasElement {
        display: none;
    }
    
    /* PDF.js styles */
    .flipbook-page {
        .textLayer {
          position: absolute;
          text-align: initial;
          inset: 0;
          overflow: clip;
          opacity: 1;
          line-height: 1;
          text-size-adjust: none;
          forced-color-adjust: none;
          transform-origin: 0 0;
          caret-color: CanvasText;
          z-index: 0;
          
          ::selection {
              color: transparent;
          }
        
          &.highlighting {
            touch-action: none;
          }
        
          :is(span, br) {
            color: transparent;
            position: absolute;
            white-space: pre;
            cursor: text;
            transform-origin: 0% 0%;
          }
        
          > :not(.markedContent),
          .markedContent span:not(.markedContent) {
            z-index: 1;
          }
        
          /* Only necessary in Google Chrome, see issue 14205, and most unfortunately
           * the problem doesn't show up in "text" reference tests. */
          /*#if !MOZCENTRAL*/
          span.markedContent {
            top: 0;
            height: 0;
          }
          /*#endif*/
        
          span[role="img"] {
            user-select: none;
            cursor: default;
          }
        
          .highlight {
            --highlight-bg-color: rgb(180 0 170 / 0.25);
            --highlight-selected-bg-color: rgb(0 100 0 / 0.25);
            --highlight-backdrop-filter: none;
            --highlight-selected-backdrop-filter: none;
            
            margin: -1px;
            padding: 1px;
            background-color: var(--highlight-bg-color);
            backdrop-filter: var(--highlight-backdrop-filter);
            border-radius: 4px;
        
            @media screen and (forced-colors: active) {
              --highlight-bg-color: transparent;
              --highlight-selected-bg-color: transparent;
              --highlight-backdrop-filter: var(--hcm-highlight-filter);
              --highlight-selected-backdrop-filter: var(
                --hcm-highlight-selected-filter
              );
            }
        
            &.appended {
              position: initial;
            }
        
            &.begin {
              border-radius: 4px 0 0 4px;
            }
        
            &.end {
              border-radius: 0 4px 4px 0;
            }
        
            &.middle {
              border-radius: 0;
            }
        
            &.selected {
              background-color: var(--highlight-selected-bg-color);
              backdrop-filter: var(--highlight-selected-backdrop-filter);
            }
          }
        
          ::selection {
            /* stylelint-disable declaration-block-no-duplicate-properties */
            /*#if !MOZCENTRAL*/
            background: rgba(0 0 255 / 0.25);
            /*#endif*/
            /* stylelint-enable declaration-block-no-duplicate-properties */
            background: color-mix(in srgb, AccentColor, transparent 75%);
          }
        
          /* Avoids https://github.com/mozilla/pdf.js/issues/13840 in Chrome */
          /*#if !MOZCENTRAL*/
          br::selection {
            background: transparent;
          }
          /*#endif*/
        
          .endOfContent {
            display: block;
            position: absolute;
            inset: 100% 0 0;
            z-index: 0;
            cursor: default;
            user-select: none;
          }
        
          &.selecting .endOfContent {
            top: 0;
          }
        }
    }
</style>

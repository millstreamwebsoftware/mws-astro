---
import Section from "@layouts/Section.astro";
import Icon from "@shared/icon.astro";
import Image from "@shared/Image.astro";
import { formatBytes } from "@mws-astro/util";
import { getFilesize } from "@mws-astro/filesystem";
import { getPDFThumbnail } from "@mws-astro/pdf";

export interface Props {
  title?: string;
  url?: string;
}

const {title, url} = Astro.props;

var thumbnail, filesize;

if (url) {
  thumbnail = (await getPDFThumbnail(url))?.replace(/^\/?public/, "");
  filesize = await getFilesize(url);
}
---
<Section component="flipbook" {...Astro.props}>
    <div class="flipbook" data-flipbook={url}>
        <div class="flipbook-preview">
            {thumbnail && <img
                src={thumbnail}
            />}
            <div class="flipbook-details">
                {title && <h1>{title}</h1>}
                {filesize && <p>{formatBytes(filesize)}</p>}
                <div class="flipbook-progress"></div>
                <div class="flipbook-buttons">
                    <button class="flipbook-read">Read <Icon name="carbon:notebook-reference" height="1.25em"/></button>
                    <button class="flipbook-download"><Icon name="carbon:download" height="1.25em"/></button>
                </div>
            </div>
        </div>
        <div class="flipbook-viewport">
        </div>
        <div class="toolbar">
            <button data-action="<" title="Previous Page"><Icon name="carbon:chevron-left" height="1em"/></button>
            <button data-action="page-number" title="Page Number">1/1</button>
            <button data-action=">" title="Next Page"><Icon name="carbon:chevron-right" height="1em"/></button>
            <button data-action="download" title="Download PDF"><Icon name="carbon:download" height="1em"/></button>
        </div>
    </div>
</Section>

<script>
import type { PDFDocument } from "mupdf";
// import PDFJSWorker from "pdfjs-dist/build/pdf.worker.min?worker&url";
// import type { OnProgressParameters } from "pdfjs-dist/types/src/display/api";
// type ResizeableCanvas = HTMLCanvasElement & {_resize?: Function};

// var getDocument: Function | undefined = undefined;
// var TextLayer: any | undefined = undefined;
// var GlobalWorkerOptions: any | undefined = undefined;
var mupdf: typeof import("mupdf") | undefined;

setupFlipbook();

async function importPDFJS() {
  // if (getDocument && TextLayer && GlobalWorkerOptions) return;
  // console.log("Imported PDF.JS");
  if (mupdf) return;

  mupdf = await import("mupdf");
  // const PDFJS = await import("pdfjs-dist");
  // ({getDocument, TextLayer, GlobalWorkerOptions} = PDFJS);
  // GlobalWorkerOptions.workerSrc = PDFJSWorker;
}

async function setupFlipbook() {
  const flipbooks = document.querySelectorAll<HTMLElement>("[data-flipbook]");

  flipbooks.forEach(async (flipbook) => {
    const flipbookPreview = flipbook.querySelector<HTMLDivElement>(".flipbook-preview");
    const flipbookButton = flipbookPreview?.querySelector<HTMLButtonElement>("button.flipbook-read");
    const flipbookDownloadButton = flipbookPreview?.querySelector<HTMLButtonElement>("button.flipbook-download");
    const flipbookProgress = flipbookPreview?.querySelector<HTMLDivElement>(".flipbook-progress");
    const flipbookViewport = flipbook.querySelector<HTMLDivElement>(".flipbook-viewport");
    const toolbar = flipbook.querySelector(".toolbar");
    const pageCounter = toolbar?.querySelector('[data-action="page-number"]');

    flipbookButton?.addEventListener("click", startFlipbook);
    flipbookDownloadButton?.addEventListener("click", download);

    function download() {
      const a = document.createElement('a');
      const url = flipbook.dataset?.flipbook;
      if (!url) return;
      a.href = url;
      a.download = url.split('/').pop() || "";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    }

    async function fetchDocument(url: string): Promise<PDFDocument|undefined> {
      if (!mupdf) return;
      let response = await fetch(url);
      if (!response.ok) {
        console.error(`Cannot fetch document: ${response.statusText}`);
        return;
      }

      let data = await response.arrayBuffer();
      return mupdf.PDFDocument.openDocument(data, url) as PDFDocument;
    }

    async function startFlipbook() {
      await importPDFJS();
      if (!flipbookViewport || !flipbook.dataset.flipbook) return;


      // const loadTask = getDocument?.(flipbook.dataset.flipbook);
      // loadTask.onProgress = (progress: OnProgressParameters) => {
      //   flipbookProgress?.setAttribute("style", `--progress:${(progress.loaded / progress.total).toFixed(2)};`);
      // };
      flipbook.classList.toggle("loading",true);
      // const pdf = await loadTask.promise;
      const pdf = await fetchDocument(flipbook.dataset.flipbook);
      if (!pdf) return;
      flipbook.classList.toggle("loading",false);
      flipbook.classList.toggle("loaded",true);

      // const singlePage = pdf.numPages === 1;
      const numPages = pdf.countPages();
      const singlePage = numPages === 1;
      flipbook.classList.toggle("singlepage", singlePage);

      const spreadSize = 2 - Number(singlePage);
      const evenSpreads = !singlePage;
      let page = 0;

      updateCounter();

      addSpread(true);
      addSpread();
      addSpread(false);

      function updateCounter() {
        if (!pageCounter) return;

        // pageCounter.innerHTML = `${Math.max(Math.min(page + Number(!evenSpreads), pdf.numPages), 1)}/${pdf.numPages}`;
        pageCounter.innerHTML = `${Math.max(Math.min(page + Number(!evenSpreads), numPages), 1)}/${numPages}`;
      }

      async function addSpread(prepend?: boolean) {
        const newSpread = document.createElement("div");
        newSpread.classList.add("flipbook-spread");
        (typeof prepend === "boolean") && newSpread.classList.add(prepend ? "previous" : "next");

        const newPage = document.createElement("div");
        const newCanvas = document.createElement("canvas");
        const newTextLayer = document.createElement("div");
        newPage.classList.add("flipbook-page")
        newTextLayer.classList.add("textLayer");
        newPage.appendChild(newCanvas);
        newPage.appendChild(newTextLayer);
        !singlePage && newSpread.appendChild(newPage.cloneNode(true));
        newSpread.appendChild(newPage);

        if (prepend) {
          flipbookViewport?.prepend(newSpread);
        } else {
          flipbookViewport?.append(newSpread);
        };

        return await renderSpread(newSpread);
      }

      async function turnPage(backward: boolean = false) {
        // const spreads = flipbookViewport.querySelectorAll<HTMLDivElement>(".flipbook-spread");
        if (!flipbookViewport) return;
        const spreads = Array.from(flipbookViewport.children);


        let oldPage = page;

        if (backward) {
          spreads.reverse()
          console.log(page, "->", page - spreadSize);
          page -= spreadSize;
        } else {
          console.log(page, "->", page + spreadSize);
          page += spreadSize;
        }

        if (page < 0) page = 0;

        // if (page < 0 - Number(evenSpreads)) page = 0 - Number(evenSpreads);
        if (page > numPages) page = oldPage;

        if (page === oldPage) return;

        const [before, current, after] = spreads;

        before.parentNode?.removeChild(before);
        current.classList.add(backward ? "next" : "previous");
        after.classList.remove("next", "previous");

        updateCounter();
        await addSpread(backward);
      }

      toolbar?.addEventListener("click", async (e) => {
        if (!e.target) return;
        const target = e.target as HTMLElement;
        const button = target.closest<HTMLButtonElement>("button, .toolbar");
        if (!button || button.matches(".toolbar")) return;

        switch (button.dataset.action) {
          case "<":
            turnPage(true);
            break;
          case ">":
            turnPage();
            break;
          case "download":
            download();
            break;
          default:
            break;
        }
      })

      async function renderPage(canvas: HTMLCanvasElement, num: number) {
        const context = canvas.getContext("2d");
        const text = canvas.parentElement?.querySelector<HTMLDivElement>(".textLayer");
        if (!pdf || !mupdf || !context || !text) return;

        if (num < 0 || num >= numPages) {
          canvas.parentElement?.classList.toggle("blank-page", true);
          return;
        }

        const page = pdf.loadPage(num);

        const dpr = Math.max(window.devicePixelRatio, 3);

        let pixmap = page.toPixmap(
          mupdf.Matrix.scale(dpr,dpr),
          mupdf.ColorSpace.DeviceRGB,
          true,
          true,
          "view",
        );

        // console.log(page.getBounds(), dpr, pixmap.getBounds());
        let stext = page.toStructuredText("preserve-whitespace").asHTML(num);

        const [width, height] = [pixmap.getWidth(), pixmap.getHeight()];
        [canvas.width, canvas.height] = [width, height];

        try {
          const data = new ImageData(pixmap.getPixels(), width, height);
          context.putImageData(data,0,0);
        } catch (e) {
          console.error(e);
        }

        text.innerHTML = stext.replaceAll(/(?<=style="[^<>]*)([0-9])pt/g,"$1px"); // .replaceAll(/(style=".*?[0-9])pt(;.*?[0-9])pt([";])/g,"$1px$2px$3");

        // @ts-ignore
        canvas._resize = () => {
            if (!canvas.clientHeight || !canvas.clientWidth) return;
            const widthScaleFactor = canvas.clientWidth / (width / dpr);
            const heightScaleFactor = canvas.clientHeight / (height / dpr);
            const scaleFactor = Math.min(widthScaleFactor, heightScaleFactor); // account for object-fit contain

            // console.log("width:",widthScaleFactor, "=", canvas.clientWidth, "/ (", width, "/", dpr, ")");
            // console.log("height:",heightScaleFactor, "=", canvas.clientHeight, "/ (", height, "/", dpr, ")");

            canvas.parentElement?.setAttribute("style", `--scale-factor: ${scaleFactor}`);
        }

        // @ts-ignore
        canvas._resize();

        const observer = new ResizeObserver((entries) => {
          entries.forEach((entry: any) => entry.target._resize && entry.target._resize());
        });

        observer.observe(canvas);
      }

      async function renderSpread(spread: HTMLDivElement) {
        const canvases = Array.from(spread.querySelectorAll("canvas"));
        var spreadOffset = 0;

        if (spread.classList.contains("next")) {
          spreadOffset += spreadSize;
        } else if (spread.classList.contains("previous")) {
          spreadOffset -= spreadSize;
        }

        return Promise.all(canvases.map(async (canvas, i) => {
          let p = page + i + spreadOffset - Number(evenSpreads);
          console.log(`Render page ${p} to`, canvas, spread.classList.toString());
          return renderPage(canvas, p);
        }));
      }
    }
  });
}
</script>


<style lang="scss">
.loaded {
    .flipbook-preview {
        display: none;
    }
}

.loading .flipbook-read, .loading .flipbook-download {
    display: none;
}

:not(.loaded) .toolbar {
    display: none;
}

.toolbar button[data-action="page-number"] {
    cursor: default;
}

.toolbar {
    /* position: absolute; */
    /* bottom: 0; */
    /* left: 50%; */

    /* transform: translateX(-50%) translateY(110%); */
    /* background-color: white; */

    display: flex;
    flex-direction: row;
    justify-content: center;
    margin-top: 1rem;

    z-index: 999;

    button {
        color: #333;
        border-color: #333;
        padding: .3em .8em;
        background-color: #fff;

        border-radius: var(--border-radius);
    }
}

.flipbook-preview {
    /* position: absolute; */
    /* inset: 0; */
    z-index: 10;
    padding: 5rem;

    max-height: 90vh;

    display: grid;
    grid-template-columns: 1fr 1fr;
    grid-template-rows: 1fr;
    gap: var(--column-gap);

    color: rgb(var(--text-color));

    img {
        min-height: 20rem;
        max-height: 100%;
        max-width: 100%;
    }

    @media only screen and (max-width: 768px) {
        grid-template-columns: 1fr;
        grid-template-rows: repeat(2, auto);
    }

    .flipbook-buttons {
        display: flex;
        flex-direction: row;
        gap: 1rem;
    }

    .flipbook-progress {
        position: relative;
        width: 20rem;
        height: 4px;
        border: 1px solid rgb(var(--text-color));
        border-radius: var(--border-radius);
        overflow: hidden;
        display: none;

        background-color: rgb(var(--text-color));

        @at-root .loading & {
            display: block;
        }

        &::after {
            content: "";
            position: absolute;

            left: 0;
            top: 0;
            right: calc((1 - var(--progress,0)) * 100%);
            bottom: 0;

            transition: right .5s ease;

            background-color: rgb(var(--color-accent));
        }
    }
}
</style>


<style lang="scss" is:global>
    div.flipbook {
        position: relative;
        /* min-height: 50rem; */


        .flipbook-preview img {
            min-height: 20rem;
        }

        .flipbook-viewport {
            display: grid;
            grid-template-areas: "flipbook";

            grid-template-rows: minmax(0, 1fr);
            perspective: 10000px;
        }

        .flipbook-spread {
            /* position: relative; */
            grid-area: flipbook;
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            grid-template-rows: 1fr;


            &.previous {
                .flipbook-page:nth-child(2) {
                    transform: rotateY(-180deg);
                }
            }
            & {
                z-index: auto;

                .flipbook-page {
                    z-index: 1;
                    transform: rotateY(0deg);
                }
            }
            &.next {
                .flipbook-page:nth-child(2) {
                    z-index: -1;
                }
                .flipbook-page:nth-child(1) {
                    transform: rotateY(180deg);
                }
            }
        }

        .flipbook-page {
            position: relative;
            transition: transform 0.2s ease-in-out, z-index 0.2s;
            backface-visibility: hidden;

            canvas {
                width: 100%;
                object-fit: contain;
                max-height: 90vh;
            }

            &:nth-child(1) {
                transform-origin: right;

                canvas {
                    object-position: right;
                }

                .textLayer {
                    right: 0;
                    /* left: unset; */
                }

                &::after {
                    background: linear-gradient(to right, transparent 80%, 95%, rgb(0, 0, 0, 0.4));
                }
            }
            &:nth-child(2) {
                transform-origin: left;

                canvas {
                    object-position: left;
                }

                .textLayer {
                    left: 0;
                }

                &::after {
                    background: linear-gradient(to left, transparent 80%, 95%, rgb(0, 0, 0, 0.4));
                }
            }

            &::after {
                content: "";
                position: absolute;
                inset: 0;
                pointer-events: none;
            }

            &.blank-page::after {
                content: none;
            }
        }

        &.singlepage {
            .flipbook-spread {
                grid-template-columns: 1fr;
            }

            .flipbook-page {
                &::after {
                    content: none;
                }
            }
        }
    }

    .hiddenCanvasElement {
        display: none;
    }

    .flipbook-page > .textLayer {
        position: absolute;
        inset: 0;
        overflow: hidden;

        span {
            color: transparent !important;

            &::selection {
                color: transparent;
            }
        }

        opacity: 0.5;

        & > div[id] {
            position: relative;
            width: 100%;
            height: 100%;
            transform: scale(var(--scale-factor, 1));
            transform-origin: top left;

            & > p {
                position: absolute;
            }
        }
    }
</style>
